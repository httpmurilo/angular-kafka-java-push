import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Inject, APP_INITIALIZER, NgModule } from '@angular/core';
import * as i1 from '@ngxs/store';
import { ofActionDispatched, getValue } from '@ngxs/store';
import { Subscription } from 'rxjs';
import { WebSocketSubject } from 'rxjs/webSocket';

const NGXS_WEBSOCKET_OPTIONS = new InjectionToken('NGXS_WEBSOCKET_OPTIONS');
function noop(..._args) {
    return function () { };
}
/**
 * Action to connect to the websocket. Optionally pass a URL.
 */
class ConnectWebSocket {
    constructor(payload) {
        this.payload = payload;
    }
}
ConnectWebSocket.type = '[WebSocket] Connect';
/**
 * Action triggered when a error ocurrs
 */
class WebsocketMessageError {
    constructor(payload) {
        this.payload = payload;
    }
}
WebsocketMessageError.type = '[WebSocket] Message Error';
/**
 * Action to disconnect the websocket.
 */
class DisconnectWebSocket {
}
DisconnectWebSocket.type = '[WebSocket] Disconnect';
/**
 * Action triggered when websocket is connected
 */
class WebSocketConnected {
}
WebSocketConnected.type = '[WebSocket] Connected';
/**
 * Action triggered when websocket is disconnected
 */
class WebSocketDisconnected {
}
WebSocketDisconnected.type = '[WebSocket] Disconnected';
/**
 * Action to send to the server.
 */
class SendWebSocketMessage {
    constructor(payload) {
        this.payload = payload;
    }
}
SendWebSocketMessage.type = '[WebSocket] Send Message';
/**
 * Action dispatched when the user tries to connect if the connection already exists.
 */
class WebSocketConnectionUpdated {
}
WebSocketConnectionUpdated.type = '[WebSocket] Connection Updated';
/**
 * This error is thrown where there is no `type` (or custom `typeKey`) property
 * on the message that came from the server side socket
 */
class TypeKeyPropertyMissingError extends Error {
    constructor(typeKey) {
        super(`Property ${typeKey} is missing on the socket message`);
    }
}

class WebSocketHandler {
    constructor(store, actions$, options) {
        this.store = store;
        this.actions$ = actions$;
        this.options = options;
        this.socket = null;
        this.config = {
            url: this.options.url,
            protocol: this.options.protocol,
            // Default binary type is `blob` for the global `WebSocket`
            binaryType: this.options.binaryType,
            serializer: this.options.serializer,
            deserializer: this.options.deserializer,
            closeObserver: {
                next: () => {
                    // ATTENTION!
                    // See https://github.com/ReactiveX/rxjs/blob/master/src/internal/observable/dom/WebSocketSubject.ts#L340
                    // RxJS socket emits `onComplete` event only if `event.wasClean` is truthy
                    // and doesn't complete socket subject if it's falsy
                    this.disconnect();
                }
            },
            openObserver: {
                next: () => this.store.dispatch(new WebSocketConnected())
            }
        };
        this.typeKey = this.options.typeKey;
        this.subscription = new Subscription();
        this.setupActionsListeners();
    }
    ngOnDestroy() {
        this.closeConnection();
        this.subscription.unsubscribe();
    }
    setupActionsListeners() {
        this.subscription.add(this.actions$.pipe(ofActionDispatched(ConnectWebSocket)).subscribe(({ payload }) => {
            this.connect(payload);
        }));
        this.subscription.add(this.actions$.pipe(ofActionDispatched(DisconnectWebSocket)).subscribe(() => {
            this.disconnect();
        }));
        this.subscription.add(this.actions$.pipe(ofActionDispatched(SendWebSocketMessage)).subscribe(({ payload }) => {
            this.send(payload);
        }));
    }
    connect(options) {
        this.updateConnection();
        // Users can pass the options in the connect method so
        // if options aren't available at DI bootstrap they have access
        // to pass them here
        if (options) {
            this.mergeConfigWithOptions(options);
        }
        this.socket = new WebSocketSubject(this.config);
        this.socket.subscribe({
            next: (message) => {
                const type = getValue(message, this.typeKey);
                if (!type) {
                    throw new TypeKeyPropertyMissingError(this.typeKey);
                }
                this.store.dispatch(Object.assign(Object.assign({}, message), { type }));
            },
            error: (error) => {
                if (error instanceof CloseEvent) {
                    this.dispatchWebSocketDisconnected();
                }
                else {
                    this.store.dispatch(new WebsocketMessageError(error));
                }
            }
        });
    }
    disconnect() {
        if (this.socket) {
            this.closeConnection();
            this.dispatchWebSocketDisconnected();
        }
    }
    send(data) {
        if (!this.socket) {
            throw new Error('You must connect to the socket before sending any data');
        }
        this.socket.next(data);
    }
    /**
     * Don't enlarge the `connect` method
     */
    mergeConfigWithOptions(options) {
        if (options.url) {
            this.config.url = options.url;
        }
        if (options.serializer) {
            this.config.serializer = options.serializer;
        }
        if (options.deserializer) {
            this.config.deserializer = options.deserializer;
        }
    }
    /**
     * To ensure we don't have any memory leaks
     * e.g. if the user occasionally dispatched `ConnectWebSocket` twice
     * then the previous subscription will still live in the memory
     * to prevent such behavior - we close the previous connection if it exists
     */
    updateConnection() {
        if (this.socket) {
            this.closeConnection();
            this.store.dispatch(new WebSocketConnectionUpdated());
        }
    }
    /**
     * Used in many places so it's better to move the code into function
     */
    dispatchWebSocketDisconnected() {
        this.store.dispatch(new WebSocketDisconnected());
    }
    closeConnection() {
        // `socket.complete()` closes the connection
        // also it doesn't invoke the `onComplete` callback that we passed
        // into `socket.subscribe(...)`
        if (this.socket !== null) {
            this.socket.complete();
            this.socket = null;
        }
    }
}
/** @nocollapse */ WebSocketHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: WebSocketHandler, deps: [{ token: i1.Store }, { token: i1.Actions }, { token: NGXS_WEBSOCKET_OPTIONS }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ WebSocketHandler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: WebSocketHandler });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: WebSocketHandler, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Store }, { type: i1.Actions }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NGXS_WEBSOCKET_OPTIONS]
                }] }]; } });

function websocketOptionsFactory(options) {
    return Object.assign({ reconnectInterval: 5000, reconnectAttempts: 10, typeKey: 'type', deserializer(e) {
            return JSON.parse(e.data);
        },
        serializer(value) {
            return JSON.stringify(value);
        } }, options);
}
const USER_OPTIONS = new InjectionToken('USER_OPTIONS');
class NgxsWebsocketPluginModule {
    static forRoot(options) {
        return {
            ngModule: NgxsWebsocketPluginModule,
            providers: [
                WebSocketHandler,
                {
                    provide: USER_OPTIONS,
                    useValue: options
                },
                {
                    provide: NGXS_WEBSOCKET_OPTIONS,
                    useFactory: websocketOptionsFactory,
                    deps: [USER_OPTIONS]
                },
                {
                    provide: APP_INITIALIZER,
                    useFactory: noop,
                    deps: [WebSocketHandler],
                    multi: true
                }
            ]
        };
    }
}
/** @nocollapse */ NgxsWebsocketPluginModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: NgxsWebsocketPluginModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ NgxsWebsocketPluginModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: NgxsWebsocketPluginModule });
/** @nocollapse */ NgxsWebsocketPluginModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: NgxsWebsocketPluginModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: NgxsWebsocketPluginModule, decorators: [{
            type: NgModule
        }] });

/**
 * The public api for consumers of @ngxs/websocket-plugin
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ConnectWebSocket, DisconnectWebSocket, NGXS_WEBSOCKET_OPTIONS, NgxsWebsocketPluginModule, SendWebSocketMessage, WebSocketConnected, WebSocketConnectionUpdated, WebSocketDisconnected, WebsocketMessageError };
//# sourceMappingURL=ngxs-websocket-plugin.js.map
