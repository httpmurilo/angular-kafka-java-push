import { Injectable, Inject } from '@angular/core';
import { Actions, Store, getValue, ofActionDispatched } from '@ngxs/store';
import { Subscription } from 'rxjs';
import { WebSocketSubject } from 'rxjs/webSocket';
import { ConnectWebSocket, DisconnectWebSocket, SendWebSocketMessage, NGXS_WEBSOCKET_OPTIONS, WebsocketMessageError, WebSocketDisconnected, TypeKeyPropertyMissingError, WebSocketConnectionUpdated, WebSocketConnected } from './symbols';
import * as i0 from "@angular/core";
import * as i1 from "@ngxs/store";
export class WebSocketHandler {
    constructor(store, actions$, options) {
        this.store = store;
        this.actions$ = actions$;
        this.options = options;
        this.socket = null;
        this.config = {
            url: this.options.url,
            protocol: this.options.protocol,
            // Default binary type is `blob` for the global `WebSocket`
            binaryType: this.options.binaryType,
            serializer: this.options.serializer,
            deserializer: this.options.deserializer,
            closeObserver: {
                next: () => {
                    // ATTENTION!
                    // See https://github.com/ReactiveX/rxjs/blob/master/src/internal/observable/dom/WebSocketSubject.ts#L340
                    // RxJS socket emits `onComplete` event only if `event.wasClean` is truthy
                    // and doesn't complete socket subject if it's falsy
                    this.disconnect();
                }
            },
            openObserver: {
                next: () => this.store.dispatch(new WebSocketConnected())
            }
        };
        this.typeKey = this.options.typeKey;
        this.subscription = new Subscription();
        this.setupActionsListeners();
    }
    ngOnDestroy() {
        this.closeConnection();
        this.subscription.unsubscribe();
    }
    setupActionsListeners() {
        this.subscription.add(this.actions$.pipe(ofActionDispatched(ConnectWebSocket)).subscribe(({ payload }) => {
            this.connect(payload);
        }));
        this.subscription.add(this.actions$.pipe(ofActionDispatched(DisconnectWebSocket)).subscribe(() => {
            this.disconnect();
        }));
        this.subscription.add(this.actions$.pipe(ofActionDispatched(SendWebSocketMessage)).subscribe(({ payload }) => {
            this.send(payload);
        }));
    }
    connect(options) {
        this.updateConnection();
        // Users can pass the options in the connect method so
        // if options aren't available at DI bootstrap they have access
        // to pass them here
        if (options) {
            this.mergeConfigWithOptions(options);
        }
        this.socket = new WebSocketSubject(this.config);
        this.socket.subscribe({
            next: (message) => {
                const type = getValue(message, this.typeKey);
                if (!type) {
                    throw new TypeKeyPropertyMissingError(this.typeKey);
                }
                this.store.dispatch(Object.assign(Object.assign({}, message), { type }));
            },
            error: (error) => {
                if (error instanceof CloseEvent) {
                    this.dispatchWebSocketDisconnected();
                }
                else {
                    this.store.dispatch(new WebsocketMessageError(error));
                }
            }
        });
    }
    disconnect() {
        if (this.socket) {
            this.closeConnection();
            this.dispatchWebSocketDisconnected();
        }
    }
    send(data) {
        if (!this.socket) {
            throw new Error('You must connect to the socket before sending any data');
        }
        this.socket.next(data);
    }
    /**
     * Don't enlarge the `connect` method
     */
    mergeConfigWithOptions(options) {
        if (options.url) {
            this.config.url = options.url;
        }
        if (options.serializer) {
            this.config.serializer = options.serializer;
        }
        if (options.deserializer) {
            this.config.deserializer = options.deserializer;
        }
    }
    /**
     * To ensure we don't have any memory leaks
     * e.g. if the user occasionally dispatched `ConnectWebSocket` twice
     * then the previous subscription will still live in the memory
     * to prevent such behavior - we close the previous connection if it exists
     */
    updateConnection() {
        if (this.socket) {
            this.closeConnection();
            this.store.dispatch(new WebSocketConnectionUpdated());
        }
    }
    /**
     * Used in many places so it's better to move the code into function
     */
    dispatchWebSocketDisconnected() {
        this.store.dispatch(new WebSocketDisconnected());
    }
    closeConnection() {
        // `socket.complete()` closes the connection
        // also it doesn't invoke the `onComplete` callback that we passed
        // into `socket.subscribe(...)`
        if (this.socket !== null) {
            this.socket.complete();
            this.socket = null;
        }
    }
}
/** @nocollapse */ WebSocketHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: WebSocketHandler, deps: [{ token: i1.Store }, { token: i1.Actions }, { token: NGXS_WEBSOCKET_OPTIONS }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ WebSocketHandler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: WebSocketHandler });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: WebSocketHandler, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Store }, { type: i1.Actions }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NGXS_WEBSOCKET_OPTIONS]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2Vic29ja2V0LWhhbmRsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wYWNrYWdlcy93ZWJzb2NrZXQtcGx1Z2luL3NyYy93ZWJzb2NrZXQtaGFuZGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUM5RCxPQUFPLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDM0UsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUVwQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQTBCLE1BQU0sZ0JBQWdCLENBQUM7QUFFMUUsT0FBTyxFQUNMLGdCQUFnQixFQUNoQixtQkFBbUIsRUFDbkIsb0JBQW9CLEVBQ3BCLHNCQUFzQixFQUV0QixxQkFBcUIsRUFDckIscUJBQXFCLEVBQ3JCLDJCQUEyQixFQUMzQiwwQkFBMEIsRUFDMUIsa0JBQWtCLEVBQ25CLE1BQU0sV0FBVyxDQUFDOzs7QUFHbkIsTUFBTSxPQUFPLGdCQUFnQjtJQTRCM0IsWUFDVSxLQUFZLEVBQ1osUUFBaUIsRUFDZSxPQUFtQztRQUZuRSxVQUFLLEdBQUwsS0FBSyxDQUFPO1FBQ1osYUFBUSxHQUFSLFFBQVEsQ0FBUztRQUNlLFlBQU8sR0FBUCxPQUFPLENBQTRCO1FBOUJyRSxXQUFNLEdBQWlDLElBQUksQ0FBQztRQUU1QyxXQUFNLEdBQWdDO1lBQzVDLEdBQUcsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUk7WUFDdEIsUUFBUSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUTtZQUMvQiwyREFBMkQ7WUFDM0QsVUFBVSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVTtZQUNuQyxVQUFVLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVO1lBQ25DLFlBQVksRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVk7WUFDdkMsYUFBYSxFQUFFO2dCQUNiLElBQUksRUFBRSxHQUFHLEVBQUU7b0JBQ1QsYUFBYTtvQkFDYix5R0FBeUc7b0JBQ3pHLDBFQUEwRTtvQkFDMUUsb0RBQW9EO29CQUNwRCxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7Z0JBQ3BCLENBQUM7YUFDRjtZQUNELFlBQVksRUFBRTtnQkFDWixJQUFJLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxrQkFBa0IsRUFBRSxDQUFDO2FBQzFEO1NBQ0YsQ0FBQztRQUVNLFlBQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQVEsQ0FBQztRQUVoQyxpQkFBWSxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFPeEMsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7SUFDL0IsQ0FBQztJQUVELFdBQVc7UUFDVCxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDdkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNsQyxDQUFDO0lBRU8scUJBQXFCO1FBQzNCLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUNuQixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFO1lBQ2pGLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDeEIsQ0FBQyxDQUFDLENBQ0gsQ0FBQztRQUVGLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUNuQixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtZQUN6RSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDcEIsQ0FBQyxDQUFDLENBQ0gsQ0FBQztRQUVGLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUNuQixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFO1lBQ3JGLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDckIsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7SUFFTyxPQUFPLENBQUMsT0FBb0M7UUFDbEQsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFFeEIsc0RBQXNEO1FBQ3RELCtEQUErRDtRQUMvRCxvQkFBb0I7UUFDcEIsSUFBSSxPQUFPLEVBQUU7WUFDWCxJQUFJLENBQUMsc0JBQXNCLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDdEM7UUFFRCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRWhELElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDO1lBQ3BCLElBQUksRUFBRSxDQUFDLE9BQVksRUFBRSxFQUFFO2dCQUNyQixNQUFNLElBQUksR0FBRyxRQUFRLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDN0MsSUFBSSxDQUFDLElBQUksRUFBRTtvQkFDVCxNQUFNLElBQUksMkJBQTJCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2lCQUNyRDtnQkFDRCxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsaUNBQU0sT0FBTyxLQUFFLElBQUksSUFBRyxDQUFDO1lBQzVDLENBQUM7WUFDRCxLQUFLLEVBQUUsQ0FBQyxLQUFVLEVBQUUsRUFBRTtnQkFDcEIsSUFBSSxLQUFLLFlBQVksVUFBVSxFQUFFO29CQUMvQixJQUFJLENBQUMsNkJBQTZCLEVBQUUsQ0FBQztpQkFDdEM7cUJBQU07b0JBQ0wsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2lCQUN2RDtZQUNILENBQUM7U0FDRixDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU8sVUFBVTtRQUNoQixJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDZixJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7WUFDdkIsSUFBSSxDQUFDLDZCQUE2QixFQUFFLENBQUM7U0FDdEM7SUFDSCxDQUFDO0lBRU8sSUFBSSxDQUFDLElBQVM7UUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyx3REFBd0QsQ0FBQyxDQUFDO1NBQzNFO1FBRUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVEOztPQUVHO0lBQ0ssc0JBQXNCLENBQUMsT0FBbUM7UUFDaEUsSUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQztTQUMvQjtRQUVELElBQUksT0FBTyxDQUFDLFVBQVUsRUFBRTtZQUN0QixJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDO1NBQzdDO1FBRUQsSUFBSSxPQUFPLENBQUMsWUFBWSxFQUFFO1lBQ3hCLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUM7U0FDakQ7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSyxnQkFBZ0I7UUFDdEIsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2YsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQ3ZCLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksMEJBQTBCLEVBQUUsQ0FBQyxDQUFDO1NBQ3ZEO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ssNkJBQTZCO1FBQ25DLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUkscUJBQXFCLEVBQUUsQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFTyxlQUFlO1FBQ3JCLDRDQUE0QztRQUM1QyxrRUFBa0U7UUFDbEUsK0JBQStCO1FBQy9CLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxJQUFJLEVBQUU7WUFDeEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUN2QixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztTQUNwQjtJQUNILENBQUM7O2lJQXZKVSxnQkFBZ0IsOERBK0JqQixzQkFBc0I7cUlBL0JyQixnQkFBZ0I7NEZBQWhCLGdCQUFnQjtrQkFENUIsVUFBVTs7MEJBZ0NOLE1BQU07MkJBQUMsc0JBQXNCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFjdGlvbnMsIFN0b3JlLCBnZXRWYWx1ZSwgb2ZBY3Rpb25EaXNwYXRjaGVkIH0gZnJvbSAnQG5neHMvc3RvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IFdlYlNvY2tldFN1YmplY3QsIFdlYlNvY2tldFN1YmplY3RDb25maWcgfSBmcm9tICdyeGpzL3dlYlNvY2tldCc7XG5cbmltcG9ydCB7XG4gIENvbm5lY3RXZWJTb2NrZXQsXG4gIERpc2Nvbm5lY3RXZWJTb2NrZXQsXG4gIFNlbmRXZWJTb2NrZXRNZXNzYWdlLFxuICBOR1hTX1dFQlNPQ0tFVF9PUFRJT05TLFxuICBOZ3hzV2Vic29ja2V0UGx1Z2luT3B0aW9ucyxcbiAgV2Vic29ja2V0TWVzc2FnZUVycm9yLFxuICBXZWJTb2NrZXREaXNjb25uZWN0ZWQsXG4gIFR5cGVLZXlQcm9wZXJ0eU1pc3NpbmdFcnJvcixcbiAgV2ViU29ja2V0Q29ubmVjdGlvblVwZGF0ZWQsXG4gIFdlYlNvY2tldENvbm5lY3RlZFxufSBmcm9tICcuL3N5bWJvbHMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgV2ViU29ja2V0SGFuZGxlciBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc29ja2V0OiBXZWJTb2NrZXRTdWJqZWN0PGFueT4gfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIGNvbmZpZzogV2ViU29ja2V0U3ViamVjdENvbmZpZzxhbnk+ID0ge1xuICAgIHVybDogdGhpcy5vcHRpb25zLnVybCEsXG4gICAgcHJvdG9jb2w6IHRoaXMub3B0aW9ucy5wcm90b2NvbCxcbiAgICAvLyBEZWZhdWx0IGJpbmFyeSB0eXBlIGlzIGBibG9iYCBmb3IgdGhlIGdsb2JhbCBgV2ViU29ja2V0YFxuICAgIGJpbmFyeVR5cGU6IHRoaXMub3B0aW9ucy5iaW5hcnlUeXBlLFxuICAgIHNlcmlhbGl6ZXI6IHRoaXMub3B0aW9ucy5zZXJpYWxpemVyLFxuICAgIGRlc2VyaWFsaXplcjogdGhpcy5vcHRpb25zLmRlc2VyaWFsaXplcixcbiAgICBjbG9zZU9ic2VydmVyOiB7XG4gICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgIC8vIEFUVEVOVElPTiFcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SZWFjdGl2ZVgvcnhqcy9ibG9iL21hc3Rlci9zcmMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9kb20vV2ViU29ja2V0U3ViamVjdC50cyNMMzQwXG4gICAgICAgIC8vIFJ4SlMgc29ja2V0IGVtaXRzIGBvbkNvbXBsZXRlYCBldmVudCBvbmx5IGlmIGBldmVudC53YXNDbGVhbmAgaXMgdHJ1dGh5XG4gICAgICAgIC8vIGFuZCBkb2Vzbid0IGNvbXBsZXRlIHNvY2tldCBzdWJqZWN0IGlmIGl0J3MgZmFsc3lcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvcGVuT2JzZXJ2ZXI6IHtcbiAgICAgIG5leHQ6ICgpID0+IHRoaXMuc3RvcmUuZGlzcGF0Y2gobmV3IFdlYlNvY2tldENvbm5lY3RlZCgpKVxuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIHR5cGVLZXkgPSB0aGlzLm9wdGlvbnMudHlwZUtleSE7XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBzdG9yZTogU3RvcmUsXG4gICAgcHJpdmF0ZSBhY3Rpb25zJDogQWN0aW9ucyxcbiAgICBASW5qZWN0KE5HWFNfV0VCU09DS0VUX09QVElPTlMpIHByaXZhdGUgb3B0aW9uczogTmd4c1dlYnNvY2tldFBsdWdpbk9wdGlvbnNcbiAgKSB7XG4gICAgdGhpcy5zZXR1cEFjdGlvbnNMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uKCk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBBY3Rpb25zTGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uLmFkZChcbiAgICAgIHRoaXMuYWN0aW9ucyQucGlwZShvZkFjdGlvbkRpc3BhdGNoZWQoQ29ubmVjdFdlYlNvY2tldCkpLnN1YnNjcmliZSgoeyBwYXlsb2FkIH0pID0+IHtcbiAgICAgICAgdGhpcy5jb25uZWN0KHBheWxvYWQpO1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb24uYWRkKFxuICAgICAgdGhpcy5hY3Rpb25zJC5waXBlKG9mQWN0aW9uRGlzcGF0Y2hlZChEaXNjb25uZWN0V2ViU29ja2V0KSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbi5hZGQoXG4gICAgICB0aGlzLmFjdGlvbnMkLnBpcGUob2ZBY3Rpb25EaXNwYXRjaGVkKFNlbmRXZWJTb2NrZXRNZXNzYWdlKSkuc3Vic2NyaWJlKCh7IHBheWxvYWQgfSkgPT4ge1xuICAgICAgICB0aGlzLnNlbmQocGF5bG9hZCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGNvbm5lY3Qob3B0aW9ucz86IE5neHNXZWJzb2NrZXRQbHVnaW5PcHRpb25zKTogdm9pZCB7XG4gICAgdGhpcy51cGRhdGVDb25uZWN0aW9uKCk7XG5cbiAgICAvLyBVc2VycyBjYW4gcGFzcyB0aGUgb3B0aW9ucyBpbiB0aGUgY29ubmVjdCBtZXRob2Qgc29cbiAgICAvLyBpZiBvcHRpb25zIGFyZW4ndCBhdmFpbGFibGUgYXQgREkgYm9vdHN0cmFwIHRoZXkgaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byBwYXNzIHRoZW0gaGVyZVxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0aGlzLm1lcmdlQ29uZmlnV2l0aE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdGhpcy5zb2NrZXQgPSBuZXcgV2ViU29ja2V0U3ViamVjdCh0aGlzLmNvbmZpZyk7XG5cbiAgICB0aGlzLnNvY2tldC5zdWJzY3JpYmUoe1xuICAgICAgbmV4dDogKG1lc3NhZ2U6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCB0eXBlID0gZ2V0VmFsdWUobWVzc2FnZSwgdGhpcy50eXBlS2V5KTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVLZXlQcm9wZXJ0eU1pc3NpbmdFcnJvcih0aGlzLnR5cGVLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goeyAuLi5tZXNzYWdlLCB0eXBlIH0pO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiAoZXJyb3I6IGFueSkgPT4ge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDbG9zZUV2ZW50KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaFdlYlNvY2tldERpc2Nvbm5lY3RlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2gobmV3IFdlYnNvY2tldE1lc3NhZ2VFcnJvcihlcnJvcikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGRpc2Nvbm5lY3QoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICB0aGlzLmNsb3NlQ29ubmVjdGlvbigpO1xuICAgICAgdGhpcy5kaXNwYXRjaFdlYlNvY2tldERpc2Nvbm5lY3RlZCgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2VuZChkYXRhOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuc29ja2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGNvbm5lY3QgdG8gdGhlIHNvY2tldCBiZWZvcmUgc2VuZGluZyBhbnkgZGF0YScpO1xuICAgIH1cblxuICAgIHRoaXMuc29ja2V0Lm5leHQoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogRG9uJ3QgZW5sYXJnZSB0aGUgYGNvbm5lY3RgIG1ldGhvZFxuICAgKi9cbiAgcHJpdmF0ZSBtZXJnZUNvbmZpZ1dpdGhPcHRpb25zKG9wdGlvbnM6IE5neHNXZWJzb2NrZXRQbHVnaW5PcHRpb25zKTogdm9pZCB7XG4gICAgaWYgKG9wdGlvbnMudXJsKSB7XG4gICAgICB0aGlzLmNvbmZpZy51cmwgPSBvcHRpb25zLnVybDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zZXJpYWxpemVyKSB7XG4gICAgICB0aGlzLmNvbmZpZy5zZXJpYWxpemVyID0gb3B0aW9ucy5zZXJpYWxpemVyO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmRlc2VyaWFsaXplcikge1xuICAgICAgdGhpcy5jb25maWcuZGVzZXJpYWxpemVyID0gb3B0aW9ucy5kZXNlcmlhbGl6ZXI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRvIGVuc3VyZSB3ZSBkb24ndCBoYXZlIGFueSBtZW1vcnkgbGVha3NcbiAgICogZS5nLiBpZiB0aGUgdXNlciBvY2Nhc2lvbmFsbHkgZGlzcGF0Y2hlZCBgQ29ubmVjdFdlYlNvY2tldGAgdHdpY2VcbiAgICogdGhlbiB0aGUgcHJldmlvdXMgc3Vic2NyaXB0aW9uIHdpbGwgc3RpbGwgbGl2ZSBpbiB0aGUgbWVtb3J5XG4gICAqIHRvIHByZXZlbnQgc3VjaCBiZWhhdmlvciAtIHdlIGNsb3NlIHRoZSBwcmV2aW91cyBjb25uZWN0aW9uIGlmIGl0IGV4aXN0c1xuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVDb25uZWN0aW9uKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnNvY2tldCkge1xuICAgICAgdGhpcy5jbG9zZUNvbm5lY3Rpb24oKTtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2gobmV3IFdlYlNvY2tldENvbm5lY3Rpb25VcGRhdGVkKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGluIG1hbnkgcGxhY2VzIHNvIGl0J3MgYmV0dGVyIHRvIG1vdmUgdGhlIGNvZGUgaW50byBmdW5jdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBkaXNwYXRjaFdlYlNvY2tldERpc2Nvbm5lY3RlZCgpOiB2b2lkIHtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKG5ldyBXZWJTb2NrZXREaXNjb25uZWN0ZWQoKSk7XG4gIH1cblxuICBwcml2YXRlIGNsb3NlQ29ubmVjdGlvbigpOiB2b2lkIHtcbiAgICAvLyBgc29ja2V0LmNvbXBsZXRlKClgIGNsb3NlcyB0aGUgY29ubmVjdGlvblxuICAgIC8vIGFsc28gaXQgZG9lc24ndCBpbnZva2UgdGhlIGBvbkNvbXBsZXRlYCBjYWxsYmFjayB0aGF0IHdlIHBhc3NlZFxuICAgIC8vIGludG8gYHNvY2tldC5zdWJzY3JpYmUoLi4uKWBcbiAgICBpZiAodGhpcy5zb2NrZXQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuc29ja2V0LmNvbXBsZXRlKCk7XG4gICAgICB0aGlzLnNvY2tldCA9IG51bGw7XG4gICAgfVxuICB9XG59XG4iXX0=