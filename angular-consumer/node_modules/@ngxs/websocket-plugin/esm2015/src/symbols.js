import { InjectionToken } from '@angular/core';
export const NGXS_WEBSOCKET_OPTIONS = new InjectionToken('NGXS_WEBSOCKET_OPTIONS');
export function noop(..._args) {
    return function () { };
}
/**
 * Action to connect to the websocket. Optionally pass a URL.
 */
export class ConnectWebSocket {
    constructor(payload) {
        this.payload = payload;
    }
}
ConnectWebSocket.type = '[WebSocket] Connect';
/**
 * Action triggered when a error ocurrs
 */
export class WebsocketMessageError {
    constructor(payload) {
        this.payload = payload;
    }
}
WebsocketMessageError.type = '[WebSocket] Message Error';
/**
 * Action to disconnect the websocket.
 */
export class DisconnectWebSocket {
}
DisconnectWebSocket.type = '[WebSocket] Disconnect';
/**
 * Action triggered when websocket is connected
 */
export class WebSocketConnected {
}
WebSocketConnected.type = '[WebSocket] Connected';
/**
 * Action triggered when websocket is disconnected
 */
export class WebSocketDisconnected {
}
WebSocketDisconnected.type = '[WebSocket] Disconnected';
/**
 * Action to send to the server.
 */
export class SendWebSocketMessage {
    constructor(payload) {
        this.payload = payload;
    }
}
SendWebSocketMessage.type = '[WebSocket] Send Message';
/**
 * Action dispatched when the user tries to connect if the connection already exists.
 */
export class WebSocketConnectionUpdated {
}
WebSocketConnectionUpdated.type = '[WebSocket] Connection Updated';
/**
 * This error is thrown where there is no `type` (or custom `typeKey`) property
 * on the message that came from the server side socket
 */
export class TypeKeyPropertyMissingError extends Error {
    constructor(typeKey) {
        super(`Property ${typeKey} is missing on the socket message`);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ltYm9scy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL3dlYnNvY2tldC1wbHVnaW4vc3JjL3N5bWJvbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUvQyxNQUFNLENBQUMsTUFBTSxzQkFBc0IsR0FBRyxJQUFJLGNBQWMsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0FBb0RuRixNQUFNLFVBQVUsSUFBSSxDQUFDLEdBQUcsS0FBWTtJQUNsQyxPQUFPLGNBQWEsQ0FBQyxDQUFDO0FBQ3hCLENBQUM7QUFFRDs7R0FFRztBQUNILE1BQU0sT0FBTyxnQkFBZ0I7SUFHM0IsWUFBbUIsT0FBb0M7UUFBcEMsWUFBTyxHQUFQLE9BQU8sQ0FBNkI7SUFBRyxDQUFDOztBQUYzQyxxQkFBSSxHQUFHLHFCQUFxQixDQUFDO0FBSy9DOztHQUVHO0FBQ0gsTUFBTSxPQUFPLHFCQUFxQjtJQUdoQyxZQUFtQixPQUFZO1FBQVosWUFBTyxHQUFQLE9BQU8sQ0FBSztJQUFHLENBQUM7O0FBRm5CLDBCQUFJLEdBQUcsMkJBQTJCLENBQUM7QUFLckQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sbUJBQW1COztBQUNkLHdCQUFJLEdBQUcsd0JBQXdCLENBQUM7QUFHbEQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sa0JBQWtCOztBQUNiLHVCQUFJLEdBQUcsdUJBQXVCLENBQUM7QUFHakQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8scUJBQXFCOztBQUNoQiwwQkFBSSxHQUFHLDBCQUEwQixDQUFDO0FBR3BEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLG9CQUFvQjtJQUcvQixZQUFtQixPQUFZO1FBQVosWUFBTyxHQUFQLE9BQU8sQ0FBSztJQUFHLENBQUM7O0FBRm5CLHlCQUFJLEdBQUcsMEJBQTBCLENBQUM7QUFLcEQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sMEJBQTBCOztBQUNyQiwrQkFBSSxHQUFHLGdDQUFnQyxDQUFDO0FBRzFEOzs7R0FHRztBQUNILE1BQU0sT0FBTywyQkFBNEIsU0FBUSxLQUFLO0lBQ3BELFlBQVksT0FBZTtRQUN6QixLQUFLLENBQUMsWUFBWSxPQUFPLG1DQUFtQyxDQUFDLENBQUM7SUFDaEUsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuZXhwb3J0IGNvbnN0IE5HWFNfV0VCU09DS0VUX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ05HWFNfV0VCU09DS0VUX09QVElPTlMnKTtcblxuZXhwb3J0IGludGVyZmFjZSBOZ3hzV2Vic29ja2V0UGx1Z2luT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBVUkwgb2YgdGhlIHdlYnNvY2tldC5cbiAgICovXG4gIHVybD86IHN0cmluZztcblxuICAvKipcbiAgICogRWl0aGVyIGEgc2luZ2xlIHByb3RvY29sIHN0cmluZyBvciBhbiBhcnJheSBvZiBwcm90b2NvbCBzdHJpbmdzLlxuICAgKiBUaGVzZSBzdHJpbmdzIGFyZSB1c2VkIHRvIGluZGljYXRlIHN1Yi1wcm90b2NvbHMsIHNvIHRoYXQgYSBzaW5nbGUgc2VydmVyXG4gICAqIGNhbiBpbXBsZW1lbnQgbXVsdGlwbGUgV2ViU29ja2V0IHN1Yi1wcm90b2NvbHMgKGZvciBleGFtcGxlLCB5b3UgbWlnaHQgd2FudCBvbmUgc2VydmVyIHRvIGJlIGFibGVcbiAgICogdG8gaGFuZGxlIGRpZmZlcmVudCB0eXBlcyBvZiBpbnRlcmFjdGlvbnMgZGVwZW5kaW5nIG9uIHRoZSBzcGVjaWZpZWQgcHJvdG9jb2wpLlxuICAgKiBJZiB5b3UgZG9uJ3Qgc3BlY2lmeSBhIHByb3RvY29sIHN0cmluZywgYW4gZW1wdHkgc3RyaW5nIGlzIGFzc3VtZWQuXG4gICAqL1xuICBwcm90b2NvbD86IHN0cmluZyB8IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBgYmluYXJ5VHlwZWAgcHJvcGVydHkgb2YgdGhlIHVuZGVybHlpbmcgV2ViU29ja2V0LlxuICAgKi9cbiAgYmluYXJ5VHlwZT86ICdibG9iJyB8ICdhcnJheWJ1ZmZlcic7XG5cbiAgLyoqXG4gICAqIFRoZSBwcm9wZXJ0eSBuYW1lIHRvIGRpc3RpZ3VuaXNoIHRoaXMgdHlwZSBmb3IgdGhlIHN0b3JlLlxuICAgKiBEZWZhdWx0OiAndHlwZSdcbiAgICovXG4gIHR5cGVLZXk/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEludGVydmFsIHRvIHRyeSBhbmQgcmVjb25uZWN0LlxuICAgKiBEZWZhdWx0OiA1MDAwXG4gICAqL1xuICByZWNvbm5lY3RJbnRlcnZhbD86IG51bWJlcjtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHJlY29ubmVjdCBhdHRlbXBzLlxuICAgKiBEZWZhdWx0OiAxMFxuICAgKi9cbiAgcmVjb25uZWN0QXR0ZW1wdHM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXIgdG8gY2FsbCBiZWZvcmUgc2VuZGluZyBtZXNzYWdlc1xuICAgKiBEZWZhdWx0OiBganNvbi5zdHJpbmdpZnlgXG4gICAqL1xuICBzZXJpYWxpemVyPzogKGRhdGE6IGFueSkgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEZXNlcmFsaXplciBiZWZvcmUgcHVibGlzaGluZyB0aGUgbWVzc2FnZS5cbiAgICovXG4gIGRlc2VyaWFsaXplcj86IChlOiBNZXNzYWdlRXZlbnQpID0+IGFueTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vb3AoLi4uX2FyZ3M6IGFueVtdKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gdG8gY29ubmVjdCB0byB0aGUgd2Vic29ja2V0LiBPcHRpb25hbGx5IHBhc3MgYSBVUkwuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25uZWN0V2ViU29ja2V0IHtcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGUgPSAnW1dlYlNvY2tldF0gQ29ubmVjdCc7XG5cbiAgY29uc3RydWN0b3IocHVibGljIHBheWxvYWQ/OiBOZ3hzV2Vic29ja2V0UGx1Z2luT3B0aW9ucykge31cbn1cblxuLyoqXG4gKiBBY3Rpb24gdHJpZ2dlcmVkIHdoZW4gYSBlcnJvciBvY3VycnNcbiAqL1xuZXhwb3J0IGNsYXNzIFdlYnNvY2tldE1lc3NhZ2VFcnJvciB7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlID0gJ1tXZWJTb2NrZXRdIE1lc3NhZ2UgRXJyb3InO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwYXlsb2FkOiBhbnkpIHt9XG59XG5cbi8qKlxuICogQWN0aW9uIHRvIGRpc2Nvbm5lY3QgdGhlIHdlYnNvY2tldC5cbiAqL1xuZXhwb3J0IGNsYXNzIERpc2Nvbm5lY3RXZWJTb2NrZXQge1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZSA9ICdbV2ViU29ja2V0XSBEaXNjb25uZWN0Jztcbn1cblxuLyoqXG4gKiBBY3Rpb24gdHJpZ2dlcmVkIHdoZW4gd2Vic29ja2V0IGlzIGNvbm5lY3RlZFxuICovXG5leHBvcnQgY2xhc3MgV2ViU29ja2V0Q29ubmVjdGVkIHtcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGUgPSAnW1dlYlNvY2tldF0gQ29ubmVjdGVkJztcbn1cblxuLyoqXG4gKiBBY3Rpb24gdHJpZ2dlcmVkIHdoZW4gd2Vic29ja2V0IGlzIGRpc2Nvbm5lY3RlZFxuICovXG5leHBvcnQgY2xhc3MgV2ViU29ja2V0RGlzY29ubmVjdGVkIHtcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGUgPSAnW1dlYlNvY2tldF0gRGlzY29ubmVjdGVkJztcbn1cblxuLyoqXG4gKiBBY3Rpb24gdG8gc2VuZCB0byB0aGUgc2VydmVyLlxuICovXG5leHBvcnQgY2xhc3MgU2VuZFdlYlNvY2tldE1lc3NhZ2Uge1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZSA9ICdbV2ViU29ja2V0XSBTZW5kIE1lc3NhZ2UnO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwYXlsb2FkOiBhbnkpIHt9XG59XG5cbi8qKlxuICogQWN0aW9uIGRpc3BhdGNoZWQgd2hlbiB0aGUgdXNlciB0cmllcyB0byBjb25uZWN0IGlmIHRoZSBjb25uZWN0aW9uIGFscmVhZHkgZXhpc3RzLlxuICovXG5leHBvcnQgY2xhc3MgV2ViU29ja2V0Q29ubmVjdGlvblVwZGF0ZWQge1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZSA9ICdbV2ViU29ja2V0XSBDb25uZWN0aW9uIFVwZGF0ZWQnO1xufVxuXG4vKipcbiAqIFRoaXMgZXJyb3IgaXMgdGhyb3duIHdoZXJlIHRoZXJlIGlzIG5vIGB0eXBlYCAob3IgY3VzdG9tIGB0eXBlS2V5YCkgcHJvcGVydHlcbiAqIG9uIHRoZSBtZXNzYWdlIHRoYXQgY2FtZSBmcm9tIHRoZSBzZXJ2ZXIgc2lkZSBzb2NrZXRcbiAqL1xuZXhwb3J0IGNsYXNzIFR5cGVLZXlQcm9wZXJ0eU1pc3NpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IodHlwZUtleTogc3RyaW5nKSB7XG4gICAgc3VwZXIoYFByb3BlcnR5ICR7dHlwZUtleX0gaXMgbWlzc2luZyBvbiB0aGUgc29ja2V0IG1lc3NhZ2VgKTtcbiAgfVxufVxuIl19